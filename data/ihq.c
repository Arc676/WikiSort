//Copyright (C) 2018  Arc676/Alessandro Vinciguerra <alesvinciguerra@gmail.com>

//This program is free software: you can redistribute it and/or modify
//it under the terms of the GNU General Public License as published by
//the Free Software Foundation (version 3).

//This program is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.

//You should have received a copy of the GNU General Public License
//along with this program.  If not, see <http://www.gnu.org/licenses/>.

// ********

// Introsort/Heapsort/Quicksort test

// An introsort algorithm employs quicksort techniques until a certain
// number of iterations has been reached before switching to heapsort.
// This program generates random lists of increasing lengths and runs
// all three sorting algorithms on identical lists to compare their runtime.

// The data is outputted to a file with name set to the first argument.

// You can define the following macros during compilation to customize the test

// Number of trials to perform for each array length
#ifndef NUM_TRIALS
#define NUM_TRIALS 10
#endif

// Starting array length
#ifndef LEN_START
#define LEN_START 100
#endif

// Maximum length of array to attempt sorting
#ifndef MAX_LEN
#define MAX_LEN 10600
#endif

// Amount by which to increase array length after each test
#ifndef LEN_INC
#define LEN_INC 500
#endif

// If set to 1, array length increases by LEN_INC each time. If set to a falsy
// value, array length is scaled up by LEN_INC each time instead. Defaults to 0.
#ifndef LIN_GROWTH
#define LIN_GROWTH 0
#endif

// Upper bound for elements of list (generated by pseudo-RNG and modulo)
// (defaults to 100 i.e. elements between 0 and 99 inclusive)
#ifndef BOUND
#define BOUND 100
#endif

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#include "intro.h"

int main(int argc, char* argv[]) {
	if (argc != 2) {
		fprintf(stderr, "Usage: ihq outputFile.csv\n");
		return 1;
	}
	srand(time(NULL));
	FILE* output = fopen(argv[1], "w");
	if (!output) {
		fprintf(stderr, "Failed to open output file\n");
		return 1;
	}
	fprintf(output, "Length,");
	for (int i = 0; i < NUM_TRIALS; i++) {
		fprintf(output, "Introsort %d,", i + 1);
	}
	fprintf(output, "Introsort AVG,");
	for (int i = 0; i < NUM_TRIALS; i++) {
		fprintf(output, "Heapsort %d,", i + 1);
	}
	fprintf(output, "Heapsort AVG,");
	for (int i = 0; i < NUM_TRIALS; i++) {
		fprintf(output, "Quicksort %d,", i + 1);
	}
	fprintf(output, "Quicksort AVG\n");

	// allocate memory for list
	int* nums = malloc(MAX_LEN * sizeof(int));
	int* copy = malloc(MAX_LEN * sizeof(int));


	// allocate memory for storing times
	unsigned long data[3][NUM_TRIALS];

	for (int arrlen = LEN_START; arrlen <= MAX_LEN;) {
		for (int trial = 0; trial < NUM_TRIALS; trial++) {
			// generate random data
			for (int i = 0; i < arrlen; i++) {
				nums[i] = rand() % BOUND;
			}
			clock_t introStart, introEnd, heapStart, heapEnd, quickStart, quickEnd;

			printf("Sorting random array of length %d...\n", arrlen);
			
			// time introsort, copying data so it can be reused for
			// other sorting algorithms
			printf("Running introsort... ");
			memcpy(copy, nums, arrlen * sizeof(int));
			introStart = clock();
			introSort((void**)copy, arrlen, sizeof(int), cmp_int);
			introEnd = clock();
			data[0][trial] = introEnd - introStart;

			// time heapsort
			printf("Running heapsort... ");
			memcpy(copy, nums, arrlen * sizeof(int));
			heapStart = clock();
			heapSort((void**)copy, arrlen, sizeof(int), cmp_int);
			heapEnd = clock();
			data[1][trial] = heapEnd - heapStart;

			// time quicksort
			printf("Running quicksort...\n");
			memcpy(copy, nums, arrlen * sizeof(int));
			quickStart = clock();
			quickSort((void**)copy, arrlen, sizeof(int), cmp_int);
			quickEnd = clock();
			data[2][trial] = quickEnd - quickStart;
		}

		// log results
		fprintf(output, "%d,", arrlen);
		for (int sort = 0; sort < 3; sort++) {
			long double total = 0;
			for (int trial = 0; trial < NUM_TRIALS; trial++) {
				fprintf(output, "%lu,", data[sort][trial]);
				total += data[sort][trial];
			}
			fprintf(output, "%Lf,", total / NUM_TRIALS);
		}
		fprintf(output, "\n");
		if (LIN_GROWTH) {
			arrlen += LEN_INC;
		} else {
			arrlen *= LEN_INC;
		}
	}
	printf("Program terminated\n");
	fclose(output);
	return 0;
}
