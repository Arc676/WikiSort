//Copyright (C) 2018  Arc676/Alessandro Vinciguerra <alesvinciguerra@gmail.com>

//This program is free software: you can redistribute it and/or modify
//it under the terms of the GNU General Public License as published by
//the Free Software Foundation (version 3).

//This program is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.

//You should have received a copy of the GNU General Public License
//along with this program.  If not, see <http://www.gnu.org/licenses/>.

// ********

// Introsort/Heapsort/Quicksort test

// An introsort algorithm employs quicksort techniques until a certain
// number of iterations has been reached before switching to heapsort.
// This program generates random lists of increasing lengths and runs
// all three sorting algorithms on identical lists to compare their runtime.

// The data is outputted to a file with name set to the first argument.

// You can define the following macros during compilation to customize the test

// Upper bound for elements of list (generated by pseudo-RNG and modulo)
// (defaults to 100 i.e. elements between 0 and 99 inclusive)
#ifndef BOUND
#define BOUND 100
#endif

#include "intro.h"
#include "testprog.h"

int main(int argc, char* argv[]) {
	FILE* output = initialize(argc, argv, "ihq", 3, "Introsort", "Heapsort", "Quicksort");
	if (!output) {
		return 1;
	}

	// allocate memory for list
	int* nums = malloc(MAX_LEN * sizeof(int));
	int* copy = malloc(MAX_LEN * sizeof(int));

	// allocate memory for storing times
	unsigned long data[3][NUM_TRIALS];

	for (int arrlen = LEN_START; arrlen <= MAX_LEN;) {
		for (int trial = 0; trial < NUM_TRIALS; trial++) {
			// generate random data
			for (int i = 0; i < arrlen; i++) {
				nums[i] = rand() % BOUND;
			}
			clock_t introStart, introEnd, heapStart, heapEnd, quickStart, quickEnd;

			printf("Sorting random array of length %d...\n", arrlen);

			// time introsort, copying data so it can be reused for
			// other sorting algorithms
			printf("Running introsort... ");
			memcpy(copy, nums, arrlen * sizeof(int));
			introStart = clock();
			introSort((void**)copy, arrlen, sizeof(int), cmp_int);
			introEnd = clock();
			data[0][trial] = introEnd - introStart;

			// time heapsort
			printf("Running heapsort... ");
			memcpy(copy, nums, arrlen * sizeof(int));
			heapStart = clock();
			heapSort((void**)copy, arrlen, sizeof(int), cmp_int);
			heapEnd = clock();
			data[1][trial] = heapEnd - heapStart;

			// time quicksort
			printf("Running quicksort...\n");
			memcpy(copy, nums, arrlen * sizeof(int));
			quickStart = clock();
			quickSort((void**)copy, arrlen, sizeof(int), cmp_int);
			quickEnd = clock();
			data[2][trial] = quickEnd - quickStart;
		}

		// log results
		fprintf(output, "%d,", arrlen);
		for (int sort = 0; sort < 3; sort++) {
			long double total = 0;
			for (int trial = 0; trial < NUM_TRIALS; trial++) {
				fprintf(output, "%lu,", data[sort][trial]);
				total += data[sort][trial];
			}
			fprintf(output, "%Lf,", total / NUM_TRIALS);
		}
		fprintf(output, "\n");
		if (LIN_GROWTH) {
			arrlen += LEN_INC;
		} else {
			arrlen *= LEN_INC;
		}
	}
	printf("Program terminated\n");
	fclose(output);
	return 0;
}
